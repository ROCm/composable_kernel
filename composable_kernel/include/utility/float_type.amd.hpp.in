#ifndef CK_FLOAT_TYPE_AMD_HPP
#define CK_FLOAT_TYPE_AMD_HPP

namespace ck {

template <typename T, index_t N>
struct vector_type;

template <typename T>
struct vector_type<T, 1>
{
    using type = T;

    union
    {
        T d1_;
        StaticallyIndexedArray<T, 1> d1x1_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{type{0}} {}

    __host__ __device__ constexpr vector_type(type v) : data_{v} {}

    __host__ __device__ static constexpr index_t Size() { return 1; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d1_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d1_; }

    __host__ __device__ constexpr const auto& Scalars() const { return data_.d1x1_; }

    __host__ __device__ constexpr auto& Scalars() { return data_.d1x1_; }

    __host__ __device__ constexpr const auto& Vectors(Number<1>) const { return data_.d1x1_; }

    __host__ __device__ constexpr auto& Vectors(Number<1>) { return data_.d1x1_; }
};

template <typename T>
struct vector_type<T, 2>
{
    using d1_t = T;
    typedef T d2_t __attribute__((ext_vector_type(2)));

    using type = d2_t;

    union
    {
        d2_t d2_;
        StaticallyIndexedArray<d1_t, 2> d1x2_;
        StaticallyIndexedArray<d2_t, 1> d2x1_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{type{0}} {}

    __host__ __device__ constexpr vector_type(type v) : data_{v} {}

    __host__ __device__ static constexpr index_t Size() { return 2; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d2_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d2_; }

    __host__ __device__ constexpr const auto& Scalars() const { return data_.d1x2_; }

    __host__ __device__ constexpr auto& Scalars() { return data_.d1x2_; }

    __host__ __device__ constexpr const auto& Vectors(Number<1>) const { return data_.d1x2_; }

    __host__ __device__ constexpr const auto& Vectors(Number<2>) const { return data_.d2x1_; }

    __host__ __device__ constexpr auto& Vectors(Number<1>) { return data_.d1x2_; }

    __host__ __device__ constexpr auto& Vectors(Number<2>) { return data_.d2x1_; }
};

template <typename T>
struct vector_type<T, 4>
{
    using d1_t = T;
    typedef T d2_t __attribute__((ext_vector_type(2)));
    typedef T d4_t __attribute__((ext_vector_type(4)));

    using type = d4_t;

    union
    {
        d4_t d4_;
        StaticallyIndexedArray<d1_t, 4> d1x4_;
        StaticallyIndexedArray<d2_t, 2> d2x2_;
        StaticallyIndexedArray<d4_t, 1> d4x1_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{type{0}} {}

    __host__ __device__ constexpr vector_type(type v) : data_{v} {}

    __host__ __device__ static constexpr index_t Size() { return 4; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d4_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d4_; }

    __host__ __device__ constexpr const auto& Scalars() const { return data_.d1x4_; }

    __host__ __device__ constexpr auto& Scalars() { return data_.d1x4_; }

    __host__ __device__ constexpr const auto& Vectors(Number<1>) const { return data_.d1x4_; }

    __host__ __device__ constexpr const auto& Vectors(Number<2>) const { return data_.d2x2_; }

    __host__ __device__ constexpr const auto& Vectors(Number<4>) const { return data_.d4x1_; }

    __host__ __device__ constexpr auto& Vectors(Number<1>) { return data_.d1x4_; }

    __host__ __device__ constexpr auto& Vectors(Number<2>) { return data_.d2x2_; }

    __host__ __device__ constexpr auto& Vectors(Number<4>) { return data_.d4x1_; }
};

template <typename T>
struct vector_type<T, 8>
{
    using d1_t = T;
    typedef T d2_t __attribute__((ext_vector_type(2)));
    typedef T d4_t __attribute__((ext_vector_type(4)));
    typedef T d8_t __attribute__((ext_vector_type(8)));

    using type = d8_t;

    union
    {
        d8_t d8_;
        StaticallyIndexedArray<d1_t, 8> d1x8_;
        StaticallyIndexedArray<d2_t, 4> d2x4_;
        StaticallyIndexedArray<d4_t, 2> d4x2_;
        StaticallyIndexedArray<d8_t, 1> d8x1_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{type{0}} {}

    __host__ __device__ constexpr vector_type(type v) : data_{v} {}

    __host__ __device__ static constexpr index_t Size() { return 8; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d8_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d8_; }

    __host__ __device__ constexpr const auto& Scalars() const { return data_.d1x8_; }

    __host__ __device__ constexpr auto& Scalars() { return data_.d1x8_; }

    __host__ __device__ constexpr const auto& Vectors(Number<1>) const { return data_.d1x8_; }

    __host__ __device__ constexpr const auto& Vectors(Number<2>) const { return data_.d2x4_; }

    __host__ __device__ constexpr const auto& Vectors(Number<4>) const { return data_.d4x2_; }

    __host__ __device__ constexpr const auto& Vectors(Number<8>) const { return data_.d8x1_; }

    __host__ __device__ constexpr auto& Vectors(Number<1>) { return data_.d1x8_; }

    __host__ __device__ constexpr auto& Vectors(Number<2>) { return data_.d2x4_; }

    __host__ __device__ constexpr auto& Vectors(Number<4>) { return data_.d4x2_; }

    __host__ __device__ constexpr auto& Vectors(Number<8>) { return data_.d8x1_; }
};

template <>
struct vector_type<int8_t, 2>
{
    using d1_t = int8_t;
    typedef int16_t d2_t;

    using type = d2_t;

    union
    {
        d2_t d2_;
        StaticallyIndexedArray<d1_t, 2> d1x2_;
        StaticallyIndexedArray<d2_t, 1> d2x1_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{type{0}} {}

    __host__ __device__ constexpr vector_type(type v) : data_{v} {}

    __host__ __device__ static constexpr index_t Size() { return 2; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d2_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d2_; }

    __host__ __device__ constexpr const auto& Scalars() const { return data_.d1x2_; }

    __host__ __device__ constexpr auto& Scalars() { return data_.d1x2_; }

    __host__ __device__ constexpr const auto& Vectors(Number<1>) const { return data_.d1x2_; }

    __host__ __device__ constexpr const auto& Vectors(Number<2>) const { return data_.d2x1_; }

    __host__ __device__ constexpr auto& Vectors(Number<1>) { return data_.d1x2_; }

    __host__ __device__ constexpr auto& Vectors(Number<2>) { return data_.d2x1_; }
};

template <>
struct vector_type<int8_t, 4>
{
    using d1_t = int8_t;
    typedef int16_t d2_t;
    typedef int32_t d4_t;

    using type = d4_t;

    union
    {
        d4_t d4_;
        StaticallyIndexedArray<d1_t, 4> d1x4_;
        StaticallyIndexedArray<d2_t, 2> d2x2_;
        StaticallyIndexedArray<d4_t, 1> d4x1_;
    } data_;

    __host__ __device__ constexpr vector_type() : data_{type{0}} {}

    __host__ __device__ constexpr vector_type(type v) : data_{v} {}

    __host__ __device__ static constexpr index_t Size() { return 4; }

    __host__ __device__ constexpr const auto& Vector() const { return data_.d4_; }

    __host__ __device__ constexpr auto& Vector() { return data_.d4_; }

    __host__ __device__ constexpr const auto& Scalars() const { return data_.d1x4_; }

    __host__ __device__ constexpr auto& Scalars() { return data_.d1x4_; }

    __host__ __device__ constexpr const auto& Vectors(Number<1>) const { return data_.d1x4_; }

    __host__ __device__ constexpr const auto& Vectors(Number<2>) const { return data_.d2x2_; }

    __host__ __device__ constexpr const auto& Vectors(Number<4>) const { return data_.d4x1_; }

    __host__ __device__ constexpr auto& Vectors(Number<1>) { return data_.d1x4_; }

    __host__ __device__ constexpr auto& Vectors(Number<2>) { return data_.d2x2_; }

    __host__ __device__ constexpr auto& Vectors(Number<4>) { return data_.d4x1_; }
};

// fp32
using float2_t = typename vector_type<float, 2>::type;
using float4_t = typename vector_type<float, 4>::type;
using float8_t = typename vector_type<float, 8>::type;

// fp16
using half_t  = _Float16;
using half2_t = typename vector_type<half_t, 2>::type;
using half4_t = typename vector_type<half_t, 4>::type;
using half8_t = typename vector_type<half_t, 8>::type;

// bfp16
using ushort2_t = typename vector_type<ushort, 2>::type;
using ushort4_t = typename vector_type<ushort, 4>::type;
using ushort8_t = typename vector_type<ushort, 8>::type;

// i32
using int32x2_t = typename vector_type<int32_t, 2>::type;
using int32x4_t = typename vector_type<int32_t, 4>::type;
using int32x8_t = typename vector_type<int32_t, 8>::type;

// i8
// hack for int8x4_t, because compiler does not have native support for int8x4_t
// int8x4_t is defined as int32_t
using int8x4_t = typename vector_type<int8_t, 4>::type;

// data type conversion
template <typename T>
struct type_convert
{
    template <typename X>
    __device__ T operator()(X x) const
    {
        return static_cast<T>(x);
    }
};

template <>
template <>
__device__ float type_convert<float>::operator()<ushort>(ushort x) const
{
    return bfloat16_to_float(x);
}

template <>
template <>
__device__ ushort type_convert<ushort>::operator()<float>(float x) const
{
    return float_to_bfloat16(x);
}

template <typename T>
struct inner_product_with_conversion
{
    static constexpr auto convert = type_convert<T>();

    template <typename X, index_t N>
    __device__ T operator()(typename vector_type<X, N>::type a,
                            typename vector_type<X, N>::type b) const
    {
        const vector_type<X, N> a_vector{a};
        const vector_type<X, N> b_vector{b};

        T acc = 0;

        static_for<0, N, 1>{}([&](auto i) {
            acc += convert(a_vector.Scalars()[i]) * convert(b_vector.Scalars()[i]);
        });

        return acc;
    }

    __device__ T operator()(float_t a, float_t b) const { return convert(a) * convert(b); }

    // hack for int8x4_t, because compiler does not have native support for int8x4_t
    // int8x4_t is defined as int32_t
    __device__ T operator()(int8x4_t a, int8x4_t b) const
    {
        const vector_type<int8_t, 4> a_vector{a};
        const vector_type<int8_t, 4> b_vector{b};

        T acc = 0;

        static_for<0, 4, 1>{}([&](auto i) {
            acc += convert(a_vector.Scalars()[i]) * convert(b_vector.Scalars()[i]);
        });

        return acc;
    }
};

} // namespace ck
#endif
